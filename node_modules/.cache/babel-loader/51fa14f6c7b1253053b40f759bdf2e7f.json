{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Arg, Subject } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\n/** Represents a connection to a SignalR Hub. */\n\nvar HubConnection =\n/** @class */\nfunction () {\n  function HubConnection(connection, logger, protocol) {\n    var _this = this;\n\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.handshakeProtocol = new HandshakeProtocol();\n\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.id = 0;\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  HubConnection.create = function (connection, logger, protocol) {\n    return new HubConnection(connection, logger, protocol);\n  };\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.start = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakeRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            this.receivedHandshakeResponse = false;\n            return [4\n            /*yield*/\n            , this.connection.start(this.protocol.transferFormat)];\n\n          case 1:\n            _a.sent();\n\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4\n            /*yield*/\n            , this.connection.send(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n\n          case 2:\n            _a.sent();\n\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\"); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n            this.cleanupTimeout();\n            this.configureTimeout();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.stop = function () {\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n    this.cleanupTimeout();\n    return this.connection.stop();\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n\n\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createStreamInvocation(methodName, args);\n    var subject = new Subject(function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n\n      var cancelMessage = _this.protocol.writeMessage(cancelInvocation);\n\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return _this.connection.send(cancelMessage);\n    });\n\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      }\n\n      if (invocationEvent.type === MessageType.Completion) {\n        if (invocationEvent.error) {\n          subject.error(new Error(invocationEvent.error));\n        } else {\n          subject.complete();\n        }\n      } else {\n        subject.next(invocationEvent.item);\n      }\n    };\n\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    this.connection.send(message).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    return subject;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createInvocation(methodName, args, true);\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    return this.connection.send(message);\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createInvocation(methodName, args, false);\n    var p = new Promise(function (resolve, reject) {\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (invocationEvent.type === MessageType.Completion) {\n          var completionMessage = invocationEvent;\n\n          if (completionMessage.error) {\n            reject(new Error(completionMessage.error));\n          } else {\n            resolve(completionMessage.result);\n          }\n        } else {\n          reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n        }\n      };\n\n      var message = _this.protocol.writeMessage(invocationDescriptor);\n\n      _this.connection.send(message).catch(function (e) {\n        reject(e);\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n\n\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    } // Preventing adding the same handler multiple times.\n\n\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n\n    this.methods[methodName].push(newMethod);\n  };\n\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n\n    if (!handlers) {\n      return;\n    }\n\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n\n\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    } // Data may have all been read when processing handshake response\n\n\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n\n            if (callback != null) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n\n              callback(message);\n            }\n\n            break;\n\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\"); // We don't want to wait on the stop itself.\n            // tslint:disable-next-line:no-floating-promises\n\n            this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : null);\n            break;\n\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type);\n            break;\n        }\n      }\n    }\n\n    this.configureTimeout();\n  };\n\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n\n    var responseMessage;\n    var remainingData;\n\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message); // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n\n      this.connection.stop(error);\n      throw error;\n    }\n\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message); // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n\n      this.connection.stop(new Error(message));\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n\n    return remainingData;\n  };\n\n  HubConnection.prototype.configureTimeout = function () {\n    var _this = this;\n\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n    }\n  };\n\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n\n    if (methods) {\n      methods.forEach(function (m) {\n        return m.apply(_this, invocationMessage.arguments);\n      });\n\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message); // We don't need to wait on this Promise.\n        // tslint:disable-next-line:no-floating-promises\n\n        this.connection.stop(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n\n  HubConnection.prototype.connectionClosed = function (error) {\n    var _this = this;\n\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(undefined, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\n    });\n    this.cleanupTimeout();\n    this.closedCallbacks.forEach(function (c) {\n      return c.apply(_this, [error]);\n    });\n  };\n\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {\n    if (nonblocking) {\n      return {\n        arguments: args,\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    } else {\n      var id = this.id;\n      this.id++;\n      return {\n        arguments: args,\n        invocationId: id.toString(),\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    }\n  };\n\n  HubConnection.prototype.createStreamInvocation = function (methodName, args) {\n    var id = this.id;\n    this.id++;\n    return {\n      arguments: args,\n      invocationId: id.toString(),\n      target: methodName,\n      type: MessageType.StreamInvocation\n    };\n  };\n\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n\n  return HubConnection;\n}();\n\nexport { HubConnection };","map":{"version":3,"sources":["../../src/HubConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Arg, Subject } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly connection: IConnection;\r\n    private readonly logger: ILogger;\r\n    private protocol: IHubProtocol;\r\n    private handshakeProtocol: HandshakeProtocol;\r\n    private callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage, error?: Error) => void };\r\n    private methods: { [name: string]: Array<(...args: any[]) => void> };\r\n    private id: number;\r\n    private closedCallbacks: Array<(error?: Error) => void>;\r\n    private timeoutHandle?: any;\r\n    private receivedHandshakeResponse: boolean;\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol): HubConnection {\r\n        return new HubConnection(connection, logger, protocol);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this.processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this.connectionClosed(error);\r\n\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.id = 0;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public async start(): Promise<void> {\r\n        const handshakeRequest: HandshakeRequestMessage = {\r\n            protocol: this.protocol.name,\r\n            version: this.protocol.version,\r\n        };\r\n\r\n        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        this.receivedHandshakeResponse = false;\r\n\r\n        await this.connection.start(this.protocol.transferFormat);\r\n\r\n        this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n        await this.connection.send(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n        this.logger.log(LogLevel.Information, `Using HubProtocol '${this.protocol.name}'.`);\r\n\r\n        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n        this.cleanupTimeout();\r\n        this.configureTimeout();\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public stop(): Promise<void> {\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        this.cleanupTimeout();\r\n        return this.connection.stop();\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const invocationDescriptor = this.createStreamInvocation(methodName, args);\r\n\r\n        const subject = new Subject<T>(() => {\r\n            const cancelInvocation: CancelInvocationMessage = this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            const cancelMessage: any = this.protocol.writeMessage(cancelInvocation);\r\n\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n\r\n            return this.connection.send(cancelMessage);\r\n        });\r\n\r\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n\r\n            if (invocationEvent.type === MessageType.Completion) {\r\n                if (invocationEvent.error) {\r\n                    subject.error(new Error(invocationEvent.error));\r\n                } else {\r\n                    subject.complete();\r\n                }\r\n            } else {\r\n                subject.next((invocationEvent.item) as T);\r\n            }\r\n        };\r\n\r\n        const message = this.protocol.writeMessage(invocationDescriptor);\r\n\r\n        this.connection.send(message)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        return subject;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const invocationDescriptor = this.createInvocation(methodName, args, true);\r\n\r\n        const message = this.protocol.writeMessage(invocationDescriptor);\r\n\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const invocationDescriptor = this.createInvocation(methodName, args, false);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: StreamItemMessage | CompletionMessage, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    const completionMessage = invocationEvent as CompletionMessage;\r\n                    if (completionMessage.error) {\r\n                        reject(new Error(completionMessage.error));\r\n                    } else {\r\n                        resolve(completionMessage.result);\r\n                    }\r\n                } else {\r\n                    reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                }\r\n            };\r\n\r\n            const message = this.protocol.writeMessage(invocationDescriptor);\r\n\r\n            this.connection.send(message)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    delete this.callbacks[invocationDescriptor.invocationId];\r\n                });\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => void) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @aspnet/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @aspnet/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this.methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private processIncomingData(data: any) {\r\n        this.cleanupTimeout();\r\n\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this.protocol.parseMessages(data, this.logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        const callback = this.callbacks[message.invocationId];\r\n                        if (callback != null) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        // We don't want to wait on the stop itself.\r\n                        // tslint:disable-next-line:no-floating-promises\r\n                        this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : null);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.configureTimeout();\r\n    }\r\n\r\n    private processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(new Error(message));\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        return remainingData;\r\n    }\r\n\r\n    private configureTimeout() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n        }\r\n    }\r\n\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n\r\n                // We don't need to wait on this Promise.\r\n                // tslint:disable-next-line:no-floating-promises\r\n                this.connection.stop(new Error(message));\r\n            }\r\n        } else {\r\n            this.logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n\r\n    private connectionClosed(error?: Error) {\r\n        const callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                callback(undefined, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\r\n            });\r\n\r\n        this.cleanupTimeout();\r\n\r\n        this.closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n    }\r\n\r\n    private cleanupTimeout(): void {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private createInvocation(methodName: string, args: any[], nonblocking: boolean): InvocationMessage {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        } else {\r\n            const id = this.id;\r\n            this.id++;\r\n\r\n            return {\r\n                arguments: args,\r\n                invocationId: id.toString(),\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private createStreamInvocation(methodName: string, args: any[]): StreamInvocationMessage {\r\n        const id = this.id;\r\n        this.id++;\r\n\r\n        return {\r\n            arguments: args,\r\n            invocationId: id.toString(),\r\n            target: methodName,\r\n            type: MessageType.StreamInvocation,\r\n        };\r\n    }\r\n\r\n    private createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}